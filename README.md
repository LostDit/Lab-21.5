# [1. Ведомость учёта](https://github.com/LostDit/Lab-21.5/tree/master/Task%201)
## Что нужно сделать
Вы уже создавали программу чтения и записи ведомости. Теперь её нужно обобщить и дополнить использованием структур.
Формат ведомости прежний:
* сначала — имя и фамилия получателя денег;
* далее — дата выдачи в формате ДД.ММ.ГГГГ;
* затем — сумма выплаты в рублях.
Данные разделяются пробелами. В конце каждой записи должен быть перевод строки. Структура данных должна соответствовать этому формату.

При старте программы пользователь отправляет команду: `list` или `add`. Команда `list` осуществляет чтение из файла ведомости, как и прежде, только уже в структуре данных, и отображает их на экране.

Команда add добавляет новую запись в конец ведомости.

## Советы и рекомендации
* Чтобы определить, где заканчивается файл, используйте функцию `file.eof().`
* Из-за завершающего переноса строки при чтении данных из файла стоит отдельно прочитать имя получателя денег. Если после чтения имени получателя денег признак `file.eof()` принял значение true — значит, файл закончился.
* Используйте вектор структур. Для выбора команды потребуется подобная конструкция:
```  
if (command == "list")
{
…
}
```

---------

# [2. Модель данных для посёлка](https://github.com/LostDit/Lab-21.5/tree/master/Task%202)
## Что нужно сделать
Используя структуры данных, создайте подробную модель посёлка.

## Что известно:

- Посёлок состоит из участков, у каждого участка свой номер.
- На любом участке может стоять жилой дом, а также другие сооружения: 
  - гараж, 
  - сарай (бытовка),
  - баня. 
- Дана информация о площади, которую каждое здание занимает на участке.
- В доме может быть 1–3 этажа, на этаже — 2–4 комнаты:
  - спальня,
  - кухня,
  - ванная,
  - детская,
  - гостиная.
- Дана информация о количестве комнат и высоте потолка на каждом этаже.
- Дана информация о площади, которую занимает каждая комната.
- В доме и бане может быть печь с трубой.
Для всех упомянутых сущностей нужно объявить структуры данных.

## Обязательно для выполнения задания
Опишите структуры данных для создания модели посёлка. Структуры должны быть:

- связными и легко расширяемыми,
- без дублирующих конструкций.
Реализуйте заполнение структур данных.

Пользователь заполняет данные о посёлке: вводит общее количество участков, а потом детализирует каждый.

Сначала указывается количество построек на участке, а затем — информация, какие это постройки, сколько этажей в доме, какие комнаты на этажах.

После ввода данных можно рассчитать суммарный параметр, например процент земли, занимаемой постройками, от общей площади посёлка. Главное в этой задаче не операция подсчёта, а структуры данных.

## Советы и рекомендации
* Используйте знания о типах данных в C++. 
* Можете применять перечисления и векторы, создавать структуры внутри структур и так далее.
* Перечислите комнаты и типы зданий следующим образом:
```
enum room_type
{
    living,
    children,
    …
```
- Затем используйте полученный тип внутри структуры. Алгоритм заполнения каждого объекта одинаковый: 
  - создать объект нужного типа, 
  - ввести с клавиатуры значения, 
  - добавить объект в вектор при помощи push_back.

---------

# [3. Математический вектор](https://github.com/LostDit/Lab-21.5/blob/master/Task%203/Task%203.cpp)
## Что нужно сделать
Реализуйте структуру двумерного математического вектора и основные операции над ним.
Обе координаты вектора (x и y) должны быть вещественными числами.

Начиная работу с программой, пользователь вводит команду. Затем в зависимости от команды пользователь вводит аргументы. Это могут быть как векторы, так и обычные скалярные значения. Результат помещается в стандартный вывод. Это тоже может быть или вектор, или скаляр.

Реализуйте в виде отдельных функций операции:
* сложение двух векторов — команда `add`;
* вычитание двух векторов — команда `subtract`;
* умножение вектора на скаляр — команда `scale`;
* нахождение длины вектора — команда `length`;
* нормализация вектора — команда `normalize`.
## Советы и рекомендации
* Для выбора команды используйте конструкцию вида `if (operation == "add")`. Тут так и напрашиваются отдельные функции для каждой операции.

---------

# 4. Пошаговая ролевая игра (дополнительная задача)
## Что нужно сделать
Реализуйте упрощённую версию пошаговой ролевой игры.

Действие разворачивается на карте размером 20 на 20 клеток. По клеткам перемещаются игрок и его противники.

После каждого хода игрока карта показывается вновь со всеми противниками на ней:
* игрок помечается буквой P; 
* противники — буквой E;
* пустые места — точкой.

Каждый персонаж игры представлен в виде структуры с полями: 
* «Имя»;
* «Жизни»;
* «Броня»;
* «Урон».

Сначала создаётся пять противников в случайных клетках карты:
* Имена противникам задаются в формате Enemy #N, где N — порядковый номер. 
* Уровень жизни противников задаётся случайно — от 50 до 150. 
* Уровень брони варьируется от 0 до 50. 
* Урон тоже выбирается случайно — от 15 до 30.

Игрок конструирует своего персонажа самостоятельно. Задаёт все его параметры, включая имя. Все персонажи появляются в случайных местах карты.

Игрок ходит с помощью команд: L, R, U, D (по первым буквам слов left, right, up, down). В зависимости от команды выбирается направление перемещения: влево, вправо, вверх, вниз.

Противники перемещаются в случайном направлении.

Если игрок перемещается в сторону, где уже кто-то находится, он наносит этому персонажу урон. Противники при этом никогда не бьют друг друга: они просто пропускают ход и остаются на своём месте. За пределы карты (20 на 20 клеток) ходить нельзя никому. Если кто-то выбрал направление за границами, ход пропускается.

Формула расчёта урона совпадает с той, что была в материале. Жизни уменьшаются на размер урона. При этом броня тоже сокращается на приведённый урон.

Игра заканчивается, когда умирают либо все противники, либо игрок. В первом случае на экран выводится сообщение о победе, во втором — о поражении.

Если в начале хода игрок вводит команду save или load вместо направления перемещения, то игра либо сохраняет своё состояние в файл, либо загружает это состояние из файла.

## Советы и рекомендации
* Для определения команды персонажа можно внутри структуры данных о нём завести флаг.
* Для отображения координат персонажей можно использовать структуру вектора из другой задачи, но заменить типы координат.
* Для сохранения параметров игры и их загрузки можно работать с текстовыми данными. Однако записать всё в двоичном формате проще, главное — соблюдать последовательность полей:
```
std::ofstream file("save.bin", std::ios::binary);
    for (int i = 0; i < 6; ++i) {

        file.write((char*)&(characters[i].position),
                   sizeof(characters[i].position));
…
```
* При загрузке используйте ifstream и ту же последовательность полей.
* Задание необязательно сдавать на проверку. Но если хотите это сделать, куратор будет учитывать следующее: 
* Корректно работает сохранение и загрузка в игре.
* После загрузки все атрибуты игрока, включая имя, восстанавливаются из файла.
* После загрузки количество противников на поле соответствует количеству противников при сохранении.
* Все игроки после загрузки появляются в местах, где они находились при сохранении.
* При ходе игрока не появляются новые противники.
* Перед загрузкой файла сохранения проверяется, есть ли он в операционной системе.
